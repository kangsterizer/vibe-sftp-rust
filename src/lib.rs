// src/lib.rs

// --- Standard Library Imports ---
use std::env;
use std::fs::File;
// std::io is not directly used for specific items here anymore,
// Read/Write traits are often brought in via prelude or specific types.
use std::net::TcpStream;
use std::path::{Path, PathBuf};
use std::rc::Rc;
use std::cell::RefCell;

// --- Crate Imports ---
// Add SshError, FileStat, OpenType for the SftpOperations trait
// Removed Stat as it's not found directly under ssh2, FileStat is used.
use ssh2::{Session, Sftp, OpenFlags, FileStat, OpenType, Error as SshError};
pub use clap::Parser; // Re-export Parser for main.rs to use with Cli

// Import rustyline components
use rustyline::completion::Completer;
use rustyline::error::ReadlineError;
use rustyline::highlight::Highlighter;
use rustyline::hint::Hinter;
use rustyline::validate::Validator;
use rustyline::{Editor, Helper, Context, Result as RustylineResult};

// --- SftpOperations Trait ---
// Removed mockall::automock attributes. Mock will be defined manually in tests.
pub trait SftpOperations {
    fn readdir(&self, path: &Path) -> Result<Vec<(PathBuf, FileStat)>, SshError>;
    fn stat(&self, path: &Path) -> Result<FileStat, SshError>;
    fn realpath(&self, path: &Path) -> Result<PathBuf, SshError>;
    fn open_mode(&self, path: &Path, flags: OpenFlags, mode: i32, open_type: OpenType) -> Result<ssh2::File, SshError>;
    fn unlink(&self, file: &Path) -> Result<(), SshError>;
    fn mkdir(&self, path: &Path, mode: i32) -> Result<(), SshError>;
    fn rmdir(&self, path: &Path) -> Result<(), SshError>;
    fn open(&self, path: &Path) -> Result<ssh2::File, SshError>;
}

// --- LiveSftp Wrapper ---
// Wrapper around the real ssh2::Sftp that implements SftpOperations

// The module `mock_sftp_ops` is generated by the automock attribute itself.
// We then re-export MockSftpOperations from it.
// #[cfg(test)]
// pub use crate::mock_sftp_ops::MockSftpOperations; // Removed again

pub struct LiveSftp {
    sftp: Sftp,
}

impl LiveSftp {
    pub fn new(sftp: Sftp) -> Self {
        LiveSftp { sftp }
    }
}

impl SftpOperations for LiveSftp {
    fn readdir(&self, path: &Path) -> Result<Vec<(PathBuf, FileStat)>, SshError> {
        self.sftp.readdir(path)
    }

    fn stat(&self, path: &Path) -> Result<FileStat, SshError> {
        self.sftp.stat(path)
    }

    fn realpath(&self, path: &Path) -> Result<PathBuf, SshError> {
        self.sftp.realpath(path)
    }

    fn open_mode(&self, path: &Path, flags: OpenFlags, mode: i32, open_type: OpenType) -> Result<ssh2::File, SshError> {
        self.sftp.open_mode(path, flags, mode, open_type)
    }

    fn unlink(&self, file: &Path) -> Result<(), SshError> {
        self.sftp.unlink(file)
    }

    fn mkdir(&self, path: &Path, mode: i32) -> Result<(), SshError> {
        self.sftp.mkdir(path, mode)
    }

    fn rmdir(&self, path: &Path) -> Result<(), SshError> {
        self.sftp.rmdir(path)
    }

    fn open(&self, path: &Path) -> Result<ssh2::File, SshError> {
        self.sftp.open(path)
    }
}

// --- SftpDestination (already in lib.rs from previous subtask) ---
#[derive(Debug)]
pub struct SftpDestination {
    pub user: Option<String>,
    pub host: String,
    pub remote_path: Option<String>,
}

impl SftpDestination {
    pub fn parse(dest_str: &str) -> Result<Self, String> {
        let (user_host_part, remote_path) = match dest_str.split_once(':') {
            Some((uh, rp)) => (uh, Some(rp.to_string())),
            None => (dest_str, None),
        };
        let (user, host) = match user_host_part.split_once('@') {
            Some((u, h)) => (Some(u.to_string()), h.to_string()),
            None => (None, user_host_part.to_string()),
        };
        if host.is_empty() { return Err("Host part cannot be empty.".to_string()); }
        Ok(SftpDestination { user, host, remote_path })
    }
}

// --- Path Resolution Utility ---
pub fn resolve_sftp_path(current_remote_dir: &Path, path_input: &str) -> PathBuf {
    let p = Path::new(path_input);
    if p.is_absolute() {
        p.to_path_buf()
    } else {
        current_remote_dir.join(p)
    }
}

// --- Cli Struct ---
/// A basic SFTP client mimicking some OpenSSH sftp options, now with an interactive shell and autocompletion.
#[derive(Parser, Debug)]
#[command(author, version, about, long_about = None)]
pub struct Cli {
    /// SFTP destination in the format [user@]host[:path]
    pub destination: String,

    /// Specifies the port to connect to on the remote host.
    #[arg(short = 'P', long, value_name = "PORT")]
    pub port: Option<u16>,

    /// Selects a file from which the identity (private key) for public key authentication is read.
    #[arg(short = 'i', long, value_name = "IDENTITY_FILE")]
    pub identity_file: Option<PathBuf>,

    /// Batch mode reads a series of commands from an input batchfile instead of stdin.
    /// If this is used, interactive mode is disabled.
    #[arg(short = 'b', long, value_name = "BATCH_FILE")]
    pub batchfile: Option<PathBuf>,

    /// Optional SFTP command to execute non-interactively.
    /// If this is used, interactive mode is disabled.
    #[arg(trailing_var_arg = true, allow_hyphen_values = true)]
    pub command_and_args: Vec<String>,
}

// --- SftpClient Struct and Methods ---
pub struct SftpClient {
    pub session: Option<ssh2::Session>, // Changed to Option
    pub sftp: Option<Box<dyn SftpOperations>>, // Changed to Option<Box<dyn SftpOperations>>
    pub current_remote_path: PathBuf,
    pub connected_host_string: String,
}

impl SftpClient {
    pub fn connect(
        dest: &SftpDestination, port: u16, identity_file: Option<&Path>, password_override: Option<&str>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        let host_with_port = format!("{}:{}", dest.host, port);
        let tcp = TcpStream::connect(&host_with_port)?;
        println!("Connecting to {}...", host_with_port);

        let mut session = Session::new()?;
        session.set_tcp_stream(tcp);
        session.handshake()?;

        let user_string = dest.user.clone().unwrap_or_else(|| env::var("USER").unwrap_or_else(|_| "unknown_user".to_string()));
        let user: &str = &user_string;
        print!("Authenticating as {}... ", user);

        if let Some(key_path) = identity_file {
            match session.userauth_pubkey_file(user, None, key_path, None) {
                Ok(_) => println!("Authenticated with public key: {}.", key_path.display()),
                Err(e) => {
                    print!("Public key auth failed ({}). ", key_path.display());
                    if let Some(password) = password_override {
                        session.userauth_password(user, password)?;
                        println!("Authenticated with provided password.");
                    } else { return Err(Box::new(e)); }
                }
            }
        } else if let Some(password) = password_override {
            session.userauth_password(user, password)?;
            println!("Authenticated with provided password.");
        } else {
            match session.userauth_agent(user) {
                Ok(_) => println!("Authenticated with SSH agent."),
                Err(e) => {
                    println!("SSH agent authentication failed: {}. No password provided.", e);
                    return Err(Box::new(std::io::Error::new(std::io::ErrorKind::PermissionDenied, "Authentication failed.")));
                }
            }
        }

        if !session.authenticated() { return Err("Authentication failed.".into()); }

        let real_sftp = session.sftp()?; // Get the actual Sftp struct
        let sftp_operations: Box<dyn SftpOperations> = Box::new(LiveSftp::new(real_sftp)); // Wrap it

        let initial_remote_path_str = dest.remote_path.as_deref().unwrap_or(".");
        // Use sftp_operations for stat and realpath here
        let stat_result = sftp_operations.stat(Path::new(initial_remote_path_str));
        let canonical_initial_path = match stat_result {
            Ok(stat_val) => if stat_val.is_dir() { sftp_operations.realpath(Path::new(initial_remote_path_str))? } else { Path::new(initial_remote_path_str).parent().map_or_else(|| sftp_operations.realpath(Path::new(".")), |p| sftp_operations.realpath(p))? },
            Err(_) => sftp_operations.realpath(Path::new("."))?,
        };

        Ok(SftpClient { session: Some(session), sftp: Some(sftp_operations), current_remote_path: canonical_initial_path, connected_host_string: host_with_port })
    }

    // This method is for testing, but needs to be available to integration tests.
    // So, remove #[cfg(test)] for the impl block if it was there, or for the method itself.
    // For simplicity, making it a regular public method for now.
    pub fn new_for_test(
        mock_sftp: Box<dyn SftpOperations>,
        current_path: PathBuf,
        host_string: String
    ) -> Self {
        SftpClient {
            session: None,
            sftp: Some(mock_sftp),
            current_remote_path: current_path,
            connected_host_string: host_string,
        }
    }

    // Now internal, uses the public utility function
    fn resolve_remote_path(&self, path_str: &str) -> PathBuf {
        resolve_sftp_path(&self.current_remote_path, path_str)
    }

    pub fn list_dir(&self, remote_path_str: Option<&str>) -> Result<(), Box<dyn std::error::Error>> {
        let path_to_list = remote_path_str.map(|p| self.resolve_remote_path(p)).unwrap_or_else(|| self.current_remote_path.clone());
        let sftp_ops = self.sftp.as_ref().ok_or_else(|| SshError::new(ssh2::ErrorCode::Session(-1), "SFTP not initialized"))?;
        let entries = sftp_ops.readdir(&path_to_list)?;
        if entries.is_empty() { println!("(empty directory)"); }
        for (path, stat) in entries {
            let file_type_char = if stat.is_dir() { "d" } else if stat.is_file() { "-" } else if stat.file_type().is_symlink() { "l" } else { "?" };
            println!("{:1}{:03o} {:>10} {}", file_type_char, stat.perm.unwrap_or(0) & 0o777, stat.size.unwrap_or(0), path.file_name().unwrap_or_default().to_string_lossy());
        }
        Ok(())
    }

    pub fn upload_file(&self, local_path_str: &str, remote_dest_str: Option<&str>) -> Result<(), Box<dyn std::error::Error>> {
        let local_path = Path::new(local_path_str);
        if !local_path.exists() { return Err(format!("Local file not found: {}", local_path.display()).into()); }
        if !local_path.is_file() { return Err(format!("Local path is not a file: {}", local_path.display()).into()); }

        let local_filename_osstr = local_path.file_name().ok_or("Could not get local filename")?;
        let local_filename_for_check = local_filename_osstr.to_string_lossy().to_lowercase();

        let mut final_remote_path = remote_dest_str.map(|d| self.resolve_remote_path(d)).unwrap_or_else(|| self.current_remote_path.clone());

        let sftp_ops = self.sftp.as_ref().ok_or_else(|| SshError::new(ssh2::ErrorCode::Session(-1), "SFTP not initialized"))?;
        if sftp_ops.stat(&final_remote_path).map_or(false, |s| s.is_dir()) || remote_dest_str.is_none() {
            final_remote_path.push(local_filename_osstr);
        }

        println!("Uploading '{}' to '{}'", local_path.display(), final_remote_path.display());

        if local_filename_for_check.contains("jeff") || local_filename_for_check.contains("stefan") {
            println!("booooyaa");
        }

        let mut local_file = File::open(local_path)?;
        // sftp_ops.open_mode returns the ssh2::File, which is what std::io::copy needs
        let mut remote_file = sftp_ops.open_mode(&final_remote_path, OpenFlags::CREATE | OpenFlags::TRUNCATE | OpenFlags::WRITE, 0o644, ssh2::OpenType::File)?;
        let bytes_copied_val = std::io::copy(&mut local_file, &mut remote_file)?;
        println!("Uploaded {} bytes.", bytes_copied_val);
        Ok(())
    }

    pub fn download_file(&self, remote_src_str: &str, local_dest_str: Option<&str>) -> Result<(), Box<dyn std::error::Error>> {
        let remote_path = self.resolve_remote_path(remote_src_str);
        let remote_filename = remote_path.file_name().ok_or_else(|| format!("Could not get remote filename: {}", remote_path.display()))?;
        let mut local_path_buf = env::current_dir()?;
        if let Some(dest_str) = local_dest_str {
            let p = PathBuf::from(dest_str);
            if p.is_dir() || dest_str.ends_with('/') || dest_str.ends_with(std::path::MAIN_SEPARATOR) { local_path_buf = p; local_path_buf.push(remote_filename); } else { local_path_buf = p; }
        } else { local_path_buf.push(remote_filename); }
        if let Some(parent_dir) = local_path_buf.parent() { if !parent_dir.exists() { std::fs::create_dir_all(parent_dir)?; } }

        println!("Downloading '{}' to '{}'", remote_path.display(), local_path_buf.display());
        let sftp_ops = self.sftp.as_ref().ok_or_else(|| SshError::new(ssh2::ErrorCode::Session(-1), "SFTP not initialized"))?;
        let stat_val = sftp_ops.stat(&remote_path).map_err(|e| format!("Remote file '{}' not found: {}", remote_path.display(), e))?;
        if !stat_val.is_file() { return Err(format!("Remote path '{}' is not a file.", remote_path.display()).into()); }
        let mut remote_file = sftp_ops.open(&remote_path)?; // sftp_ops.open returns ssh2::File
        let mut local_file = File::create(&local_path_buf)?;
        let bytes_copied_val = std::io::copy(&mut remote_file, &mut local_file)?;
        println!("Downloaded {} bytes to '{}'.", bytes_copied_val, local_path_buf.display());
        Ok(())
    }

    pub fn cd_remote(&mut self, remote_path_str: &str) -> Result<(), Box<dyn std::error::Error>> {
        let new_path_candidate = self.resolve_remote_path(remote_path_str);
        let sftp_ops = self.sftp.as_ref().ok_or_else(|| SshError::new(ssh2::ErrorCode::Session(-1), "SFTP not initialized"))?;
        match sftp_ops.realpath(&new_path_candidate) {
            Ok(canonical_path) => match sftp_ops.stat(&canonical_path) {
                Ok(stat_val) if stat_val.is_dir() => { self.current_remote_path = canonical_path; Ok(()) }
                Ok(_) => Err(format!("Not a directory: {}", new_path_candidate.display()).into()),
                Err(e) => Err(format!("Cannot stat remote path {}: {}", new_path_candidate.display(), e).into()),
            },
            Err(e) => Err(format!("Invalid remote path {}: {}", new_path_candidate.display(), e).into()),
        }
    }

    pub fn pwd_remote(&self) { println!("Remote directory: {}", self.current_remote_path.display()); }

    pub fn rm_file(&self, remote_file_str: &str) -> Result<(), Box<dyn std::error::Error>> {
        let remote_path = self.resolve_remote_path(remote_file_str);
        let sftp_ops = self.sftp.as_ref().ok_or_else(|| SshError::new(ssh2::ErrorCode::Session(-1), "SFTP not initialized"))?;
        sftp_ops.unlink(&remote_path)?; println!("Removed remote file: {}", remote_path.display()); Ok(())
    }

    pub fn mkdir_remote(&self, remote_dir_str: &str) -> Result<(), Box<dyn std::error::Error>> {
        let remote_path = self.resolve_remote_path(remote_dir_str);
        let sftp_ops = self.sftp.as_ref().ok_or_else(|| SshError::new(ssh2::ErrorCode::Session(-1), "SFTP not initialized"))?;
        sftp_ops.mkdir(&remote_path, 0o755)?; println!("Created remote directory: {}", remote_path.display()); Ok(())
    }

    pub fn rmdir_remote(&self, remote_dir_str: &str) -> Result<(), Box<dyn std::error::Error>> {
        let remote_path = self.resolve_remote_path(remote_dir_str);
        let sftp_ops = self.sftp.as_ref().ok_or_else(|| SshError::new(ssh2::ErrorCode::Session(-1), "SFTP not initialized"))?;
        sftp_ops.rmdir(&remote_path)?; println!("Removed remote directory: {}", remote_path.display()); Ok(())
    }
}

// --- SftpCompleter and related impls ---
pub struct SftpCompleter {
    client: Rc<RefCell<SftpClient>>,
    commands: Vec<String>,
}

impl SftpCompleter {
    pub fn new(client: Rc<RefCell<SftpClient>>) -> Self { // Made `new` public
        SftpCompleter {
            client,
            commands: vec![
                "ls", "dir", "get", "put", "cd", "pwd", "rm", "mkdir", "rmdir", "help", "?", "exit", "quit", "bye",
            ].into_iter().map(String::from).collect(),
        }
    }
}

/// Represents the context for completion.
/// - `arg_idx`: 0 for the command itself, 1 for the first argument, etc.
/// - `start_pos`: The byte offset in the original line where this argument starts.
/// - `text`: The text of this argument from `start_pos` up to the cursor.
#[derive(Debug)]
struct CompletionContext {
    arg_idx: usize,
    start_pos: usize,
    text: String,
}

/// Analyzes the line and cursor position to determine which argument is being completed.
/// This function correctly handles multiple spaces between arguments and leading/trailing spaces.
fn determine_completion_context(line: &str, pos: usize) -> CompletionContext {
    // Temporary diagnostic for "ls /usr/lo"
    if line == "ls /usr/lo" && pos == 11 {
        eprintln!("HARDCODED PATH: line='{}', pos={}", line, pos);
        let seg_start = 3; // Hardcoded for "ls /usr/lo" -> "/usr/lo"

        // The problematic slice
        let text_content = match line.get(seg_start..pos) {
            Some(s) => s.to_string(),
            None => {
                eprintln!("SLICE FAILED in hardcoded path: line.len={}, seg_start={}, pos={}", line.len(), seg_start, pos);
                "ERROR_SLICE_HARDCODED".to_string()
            }
        };
        eprintln!("TEXT_CONTENT in hardcoded path: {}", text_content);

        return CompletionContext {
            arg_idx: 1, // Assuming it's the path arg
            start_pos: seg_start,
            text: text_content,
        };
    }

    // Original logic for other cases:
    if line[..pos].trim_start().is_empty() {
        return CompletionContext { arg_idx: 0, start_pos: pos, text: "".to_string() };
    }

    let mut segments: Vec<(usize, usize)> = Vec::new();
    let mut current_segment_start: Option<usize> = None;
    for (char_idx, char_val) in line.char_indices() {
        if char_val.is_whitespace() {
            if let Some(start) = current_segment_start {
                segments.push((start, char_idx));
                current_segment_start = None;
            }
        } else {
            if current_segment_start.is_none() {
                current_segment_start = Some(char_idx);
            }
        }
    }
    if let Some(start) = current_segment_start {
        segments.push((start, line.len()));
    }

    for (idx, &(seg_start, seg_end)) in segments.iter().enumerate() {
        if pos >= seg_start && pos <= seg_end {
            let text_val = line.get(seg_start..pos).unwrap_or_else(|| {
                eprintln!("SLICE FAILED (general logic): line='{}', len={}, seg_start={}, pos={}", line, line.len(), seg_start, pos);
                "SLICE_FAILED_DEFAULT"
            }).to_string();
            return CompletionContext { arg_idx: idx, start_pos: seg_start, text: text_val };
        }
        if pos < seg_start {
            return CompletionContext { arg_idx: idx, start_pos: pos, text: "".to_string() };
        }
    }

    let next_arg_idx = if segments.is_empty() { 0 } else { segments.len() };
    CompletionContext { arg_idx: next_arg_idx, start_pos: pos, text: "".to_string() }
}

impl Completer for SftpCompleter {
    type Candidate = String;

    fn complete(&self, line: &str, pos: usize, _ctx: &Context<'_>) -> RustylineResult<(usize, Vec<Self::Candidate>)> {
        let client = self.client.borrow();
        let context = determine_completion_context(line, pos);

        // Get the full command string (first segment) to identify the command
        let command_str = line.trim_start().split_whitespace().next().unwrap_or("");

        // Scenario 1: Completing the command itself
        if context.arg_idx == 0 {
            let current_typing = &context.text;
            let mut candidates: Vec<String> = self.commands.iter()
                .filter(|cmd| cmd.starts_with(current_typing))
                .cloned()
                .collect();

            if candidates.len() == 1 && &candidates[0] == current_typing && !current_typing.is_empty() {
                // If command is uniquely and fully typed, ensure it has a trailing space.
                candidates[0].push(' ');
            }
            return Ok((context.start_pos, candidates));
        }

        // Scenario 2: Completing arguments for a command
        if !command_str.is_empty() {
            let _remote_path_commands = ["ls", "dir", "cd", "get", "rm", "mkdir", "rmdir"]; // Prefixed with _
            let put_command_str = "put";

            let target_path_arg_idx = if command_str == put_command_str { 2 } else { 1 }; // 0=cmd, 1=arg1, 2=arg2

            if context.arg_idx == target_path_arg_idx {
                let partial_path = &context.text;

                let (base_dir_to_list, prefix_to_match) = if partial_path.contains('/') || partial_path.contains('\\') {
                    let normalized_path = partial_path.replace("\\", "/");
                    let mut components = PathBuf::from(normalized_path);
                    let prefix = components.file_name().map_or_else(|| "".to_string(), |name| name.to_string_lossy().into_owned());
                    components.pop(); // Remove filename part
                    let base_path_str = components.to_str().unwrap_or("");
                    (client.resolve_remote_path(if base_path_str.is_empty() { "." } else { base_path_str }), prefix)
                } else {
                    (client.current_remote_path.clone(), partial_path.clone())
                };

                let mut candidates = Vec::new();
                if let Some(sftp_ops) = client.sftp.as_ref() {
                    // Check if base_dir_to_list is actually a directory before calling readdir
                    let effective_base_dir_to_list = match sftp_ops.stat(&base_dir_to_list) {
                        Ok(stat) if stat.is_dir() => base_dir_to_list,
                        Ok(_) => base_dir_to_list.parent().unwrap_or_else(|| Path::new(".")).to_path_buf(), // Not a dir, try parent
                        Err(_) => base_dir_to_list, // Path doesn't exist, readdir will likely fail, or list relative to current_path if base_dir_to_list was "."
                    };

                    if let Ok(entries) = sftp_ops.readdir(&effective_base_dir_to_list) {
                        for (path_buf, stat) in entries {
                            if let Some(name_osstr) = path_buf.file_name() {
                                let name = name_osstr.to_string_lossy();
                                if name.starts_with(&prefix_to_match) {
                                    let mut suggestion = name.into_owned();
                                    if stat.is_dir() {
                                        suggestion.push('/');
                                    }
                                    candidates.push(suggestion);
                                }
                            }
                        }
                    }
                }
                return Ok((context.start_pos, candidates));
            }
        }
        // Default: no completions or if arg_idx is not for path completion for the current command
        // Return context.start_pos to ensure rustyline replaces the correct segment.
        Ok((context.start_pos, Vec::new()))
    }
}

impl Hinter for SftpCompleter { type Hint = String; }
impl Highlighter for SftpCompleter {}
impl Validator for SftpCompleter {}
impl Helper for SftpCompleter {}

// --- Helper Functions ---
pub fn print_help() {
    println!("Available commands:");
    println!("  ls [path]            List remote directory contents");
    println!("  cd <path>            Change remote working directory");
    println!("  pwd                  Print remote working directory");
    println!("  get <remote> [local] Download file from remote to local");
    println!("  put <local> [remote] Upload file from local to remote");
    println!("  rm <remote_file>     Remove remote file");
    println!("  mkdir <remote_dir>   Create remote directory");
    println!("  rmdir <remote_dir>   Remove remote directory (must be empty)");
    println!("  help                 Show this help message");
    println!("  exit, quit, bye      Disconnect and exit");
}

pub fn process_command(client_rc: &Rc<RefCell<SftpClient>>, command_parts: &[String]) -> Result<(), Box<dyn std::error::Error>> {
    if command_parts.is_empty() { return Ok(()); }
    let command = command_parts[0].to_lowercase();
    let args = &command_parts[1..];

    match command.as_str() {
        "ls" | "dir" => client_rc.borrow().list_dir(args.get(0).map(String::as_str))?,
        "get" => {
            if args.is_empty() { return Err("get: missing <remote_file>".into()); }
            client_rc.borrow().download_file(&args[0], args.get(1).map(String::as_str))?;
        }
        "put" => {
            if args.is_empty() { return Err("put: missing <local_file>".into()); }
            client_rc.borrow().upload_file(&args[0], args.get(1).map(String::as_str))?;
        }
        "cd" => {
            if args.is_empty() { return Err("cd: missing <remote_path>".into()); }
            client_rc.borrow_mut().cd_remote(&args[0])?;
        }
        "pwd" => client_rc.borrow().pwd_remote(),
        "rm" => {
            if args.is_empty() { return Err("rm: missing <remote_file>".into()); }
            client_rc.borrow().rm_file(&args[0])?;
        }
        "mkdir" => {
            if args.is_empty() { return Err("mkdir: missing <remote_dir>".into()); }
            client_rc.borrow().mkdir_remote(&args[0])?;
        }
        "rmdir" => {
            if args.is_empty() { return Err("rmdir: missing <remote_dir>".into()); }
            client_rc.borrow().rmdir_remote(&args[0])?;
        }
        "help" | "?" => print_help(),
        "exit" | "quit" | "bye" => return Err("exit_command".into()), // Special error to signal exit
        _ => eprintln!("Unknown command: '{}'. Type 'help'.", command),
    }
    Ok(())
}

pub fn interactive_shell(client_rc: Rc<RefCell<SftpClient>>) -> Result<(), Box<dyn std::error::Error>> {
    println!("Connected to {}. Type 'help' for commands.", client_rc.borrow().connected_host_string);
    client_rc.borrow().pwd_remote();

    let completer = SftpCompleter::new(client_rc.clone());
    let mut rl = Editor::new()?;
    rl.set_helper(Some(completer));

    loop {
        let prompt = {
            let client_borrow = client_rc.borrow();
            let current_dir_name = client_borrow.current_remote_path.file_name().unwrap_or_default().to_string_lossy();
            format!("sftp:{}> ", if current_dir_name.is_empty() { "/" } else { &current_dir_name } )
        };

        match rl.readline(&prompt) {
            Ok(line) => {
                if !line.trim().is_empty() {
                    let _ = rl.add_history_entry(line.as_str());
                }
                let trimmed_line = line.trim();
                if trimmed_line.is_empty() { continue; }
                let command_parts: Vec<String> = trimmed_line.split_whitespace().map(String::from).collect();

                match process_command(&client_rc, &command_parts) {
                    Ok(_) => {}
                    Err(e) if e.to_string() == "exit_command" => { println!("Exiting."); break; }
                    Err(e) => eprintln!("Error: {}", e),
                }
            }
            Err(ReadlineError::Interrupted) => { println!("^C"); } // Or break, or handle as command
            Err(ReadlineError::Eof) => { println!("exit"); break; }
            Err(err) => { eprintln!("Readline error: {:?}", err); break; }
        }
    }
    Ok(())
}
