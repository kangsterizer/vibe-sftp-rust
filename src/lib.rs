// src/lib.rs

// --- Standard Library Imports ---
use std::env;
use std::fs::File;
// std::io is not directly used for specific items here anymore,
// Read/Write traits are often brought in via prelude or specific types.
use std::net::TcpStream;
use std::path::{Path, PathBuf};
use std::rc::Rc;
use std::cell::RefCell;

// --- Crate Imports ---
// Add SshError, FileStat, OpenType for the SftpOperations trait
// Removed Stat as it's not found directly under ssh2, FileStat is used.
use ssh2::{Session, Sftp, OpenFlags, FileStat, OpenType, Error as SshError};
pub use clap::Parser; // Re-export Parser for main.rs to use with Cli

// Import rustyline components
use rustyline::completion::Completer;
use rustyline::error::ReadlineError;
use rustyline::highlight::Highlighter;
use rustyline::hint::Hinter;
use rustyline::validate::Validator;
use rustyline::{Editor, Helper, Context, Result as RustylineResult};

// --- SftpOperations Trait ---
// Removed mockall::automock attributes. Mock will be defined manually in tests.
pub trait SftpOperations {
    fn readdir(&self, path: &Path) -> Result<Vec<(PathBuf, FileStat)>, SshError>;
    fn stat(&self, path: &Path) -> Result<FileStat, SshError>;
    fn realpath(&self, path: &Path) -> Result<PathBuf, SshError>;
    fn open_mode(&self, path: &Path, flags: OpenFlags, mode: i32, open_type: OpenType) -> Result<ssh2::File, SshError>;
    fn unlink(&self, file: &Path) -> Result<(), SshError>;
    fn mkdir(&self, path: &Path, mode: i32) -> Result<(), SshError>;
    fn rmdir(&self, path: &Path) -> Result<(), SshError>;
    fn open(&self, path: &Path) -> Result<ssh2::File, SshError>;
}

// --- LiveSftp Wrapper ---
// Wrapper around the real ssh2::Sftp that implements SftpOperations

// The module `mock_sftp_ops` is generated by the automock attribute itself.
// We then re-export MockSftpOperations from it.
// #[cfg(test)]
// pub use crate::mock_sftp_ops::MockSftpOperations; // Removed again

pub struct LiveSftp {
    sftp: Sftp,
}

impl LiveSftp {
    pub fn new(sftp: Sftp) -> Self {
        LiveSftp { sftp }
    }
}

impl SftpOperations for LiveSftp {
    fn readdir(&self, path: &Path) -> Result<Vec<(PathBuf, FileStat)>, SshError> {
        self.sftp.readdir(path)
    }

    fn stat(&self, path: &Path) -> Result<FileStat, SshError> {
        self.sftp.stat(path)
    }

    fn realpath(&self, path: &Path) -> Result<PathBuf, SshError> {
        self.sftp.realpath(path)
    }

    fn open_mode(&self, path: &Path, flags: OpenFlags, mode: i32, open_type: OpenType) -> Result<ssh2::File, SshError> {
        self.sftp.open_mode(path, flags, mode, open_type)
    }

    fn unlink(&self, file: &Path) -> Result<(), SshError> {
        self.sftp.unlink(file)
    }

    fn mkdir(&self, path: &Path, mode: i32) -> Result<(), SshError> {
        self.sftp.mkdir(path, mode)
    }

    fn rmdir(&self, path: &Path) -> Result<(), SshError> {
        self.sftp.rmdir(path)
    }

    fn open(&self, path: &Path) -> Result<ssh2::File, SshError> {
        self.sftp.open(path)
    }
}

// --- SftpDestination (already in lib.rs from previous subtask) ---
#[derive(Debug)]
pub struct SftpDestination {
    pub user: Option<String>,
    pub host: String,
    pub remote_path: Option<String>,
}

impl SftpDestination {
    pub fn parse(dest_str: &str) -> Result<Self, String> {
        let (user_host_part, remote_path) = match dest_str.split_once(':') {
            Some((uh, rp)) => (uh, Some(rp.to_string())),
            None => (dest_str, None),
        };
        let (user, host) = match user_host_part.split_once('@') {
            Some((u, h)) => (Some(u.to_string()), h.to_string()),
            None => (None, user_host_part.to_string()),
        };
        if host.is_empty() { return Err("Host part cannot be empty.".to_string()); }
        Ok(SftpDestination { user, host, remote_path })
    }
}

// --- Path Resolution Utility ---
pub fn resolve_sftp_path(current_remote_dir: &Path, path_input: &str) -> PathBuf {
    let p = Path::new(path_input);
    if p.is_absolute() {
        p.to_path_buf()
    } else {
        current_remote_dir.join(p)
    }
}

// --- Cli Struct ---
/// A basic SFTP client mimicking some OpenSSH sftp options, now with an interactive shell and autocompletion.
#[derive(Parser, Debug)]
#[command(author, version, about, long_about = None)]
pub struct Cli {
    /// SFTP destination in the format [user@]host[:path]
    pub destination: String,

    /// Specifies the port to connect to on the remote host.
    #[arg(short = 'P', long, value_name = "PORT")]
    pub port: Option<u16>,

    /// Selects a file from which the identity (private key) for public key authentication is read.
    #[arg(short = 'i', long, value_name = "IDENTITY_FILE")]
    pub identity_file: Option<PathBuf>,

    /// Batch mode reads a series of commands from an input batchfile instead of stdin.
    /// If this is used, interactive mode is disabled.
    #[arg(short = 'b', long, value_name = "BATCH_FILE")]
    pub batchfile: Option<PathBuf>,

    /// Optional SFTP command to execute non-interactively.
    /// If this is used, interactive mode is disabled.
    #[arg(trailing_var_arg = true, allow_hyphen_values = true)]
    pub command_and_args: Vec<String>,
}

// --- SftpClient Struct and Methods ---
pub struct SftpClient {
    pub session: Option<ssh2::Session>, // Changed to Option
    pub sftp: Option<Box<dyn SftpOperations>>, // Changed to Option<Box<dyn SftpOperations>>
    pub current_remote_path: PathBuf,
    pub connected_host_string: String,
}

impl SftpClient {
    pub fn connect(
        dest: &SftpDestination, port: u16, identity_file: Option<&Path>, password_override: Option<&str>,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        let host_with_port = format!("{}:{}", dest.host, port);
        let tcp = TcpStream::connect(&host_with_port)?;
        println!("Connecting to {}...", host_with_port);

        let mut session = Session::new()?;
        session.set_tcp_stream(tcp);
        session.handshake()?;

        let user_string = dest.user.clone().unwrap_or_else(|| env::var("USER").unwrap_or_else(|_| "unknown_user".to_string()));
        let user: &str = &user_string;
        print!("Authenticating as {}... ", user);

        if let Some(key_path) = identity_file {
            match session.userauth_pubkey_file(user, None, key_path, None) {
                Ok(_) => println!("Authenticated with public key: {}.", key_path.display()),
                Err(e) => {
                    print!("Public key auth failed ({}). ", key_path.display());
                    if let Some(password) = password_override {
                        session.userauth_password(user, password)?;
                        println!("Authenticated with provided password.");
                    } else { return Err(Box::new(e)); }
                }
            }
        } else if let Some(password) = password_override {
            session.userauth_password(user, password)?;
            println!("Authenticated with provided password.");
        } else {
            match session.userauth_agent(user) {
                Ok(_) => println!("Authenticated with SSH agent."),
                Err(e) => {
                    println!("SSH agent authentication failed: {}. No password provided.", e);
                    return Err(Box::new(std::io::Error::new(std::io::ErrorKind::PermissionDenied, "Authentication failed.")));
                }
            }
        }

        if !session.authenticated() { return Err("Authentication failed.".into()); }

        let real_sftp = session.sftp()?; // Get the actual Sftp struct
        let sftp_operations: Box<dyn SftpOperations> = Box::new(LiveSftp::new(real_sftp)); // Wrap it

        let initial_remote_path_str = dest.remote_path.as_deref().unwrap_or(".");
        // Use sftp_operations for stat and realpath here
        let stat_result = sftp_operations.stat(Path::new(initial_remote_path_str));
        let canonical_initial_path = match stat_result {
            Ok(stat_val) => if stat_val.is_dir() { sftp_operations.realpath(Path::new(initial_remote_path_str))? } else { Path::new(initial_remote_path_str).parent().map_or_else(|| sftp_operations.realpath(Path::new(".")), |p| sftp_operations.realpath(p))? },
            Err(_) => sftp_operations.realpath(Path::new("."))?,
        };

        Ok(SftpClient { session: Some(session), sftp: Some(sftp_operations), current_remote_path: canonical_initial_path, connected_host_string: host_with_port })
    }

    // This method is for testing, but needs to be available to integration tests.
    // So, remove #[cfg(test)] for the impl block if it was there, or for the method itself.
    // For simplicity, making it a regular public method for now.
    pub fn new_for_test(
        mock_sftp: Box<dyn SftpOperations>,
        current_path: PathBuf,
        host_string: String
    ) -> Self {
        SftpClient {
            session: None,
            sftp: Some(mock_sftp),
            current_remote_path: current_path,
            connected_host_string: host_string,
        }
    }

    // Now internal, uses the public utility function
    fn resolve_remote_path(&self, path_str: &str) -> PathBuf {
        resolve_sftp_path(&self.current_remote_path, path_str)
    }

    pub fn list_dir(&self, remote_path_str: Option<&str>) -> Result<(), Box<dyn std::error::Error>> {
        let path_to_list = remote_path_str.map(|p| self.resolve_remote_path(p)).unwrap_or_else(|| self.current_remote_path.clone());
        let sftp_ops = self.sftp.as_ref().ok_or_else(|| SshError::new(ssh2::ErrorCode::Session(-1), "SFTP not initialized"))?;
        let entries = sftp_ops.readdir(&path_to_list)?;
        if entries.is_empty() { println!("(empty directory)"); }
        for (path, stat) in entries {
            let file_type_char = if stat.is_dir() { "d" } else if stat.is_file() { "-" } else if stat.file_type().is_symlink() { "l" } else { "?" };
            println!("{:1}{:03o} {:>10} {}", file_type_char, stat.perm.unwrap_or(0) & 0o777, stat.size.unwrap_or(0), path.file_name().unwrap_or_default().to_string_lossy());
        }
        Ok(())
    }

    pub fn upload_file(&self, local_path_str: &str, remote_dest_str: Option<&str>) -> Result<(), Box<dyn std::error::Error>> {
        let local_path = Path::new(local_path_str);
        if !local_path.exists() { return Err(format!("Local file not found: {}", local_path.display()).into()); }
        if !local_path.is_file() { return Err(format!("Local path is not a file: {}", local_path.display()).into()); }

        let local_filename_osstr = local_path.file_name().ok_or("Could not get local filename")?;
        let local_filename_for_check = local_filename_osstr.to_string_lossy().to_lowercase();

        let mut final_remote_path = remote_dest_str.map(|d| self.resolve_remote_path(d)).unwrap_or_else(|| self.current_remote_path.clone());

        let sftp_ops = self.sftp.as_ref().ok_or_else(|| SshError::new(ssh2::ErrorCode::Session(-1), "SFTP not initialized"))?;
        if sftp_ops.stat(&final_remote_path).map_or(false, |s| s.is_dir()) || remote_dest_str.is_none() {
            final_remote_path.push(local_filename_osstr);
        }

        println!("Uploading '{}' to '{}'", local_path.display(), final_remote_path.display());

        if local_filename_for_check.contains("jeff") || local_filename_for_check.contains("stefan") {
            println!("booooyaa");
        }

        let mut local_file = File::open(local_path)?;
        // sftp_ops.open_mode returns the ssh2::File, which is what std::io::copy needs
        let mut remote_file = sftp_ops.open_mode(&final_remote_path, OpenFlags::CREATE | OpenFlags::TRUNCATE | OpenFlags::WRITE, 0o644, ssh2::OpenType::File)?;
        let bytes_copied_val = std::io::copy(&mut local_file, &mut remote_file)?;
        println!("Uploaded {} bytes.", bytes_copied_val);
        Ok(())
    }

    pub fn download_file(&self, remote_src_str: &str, local_dest_str: Option<&str>) -> Result<(), Box<dyn std::error::Error>> {
        let remote_path = self.resolve_remote_path(remote_src_str);
        let remote_filename = remote_path.file_name().ok_or_else(|| format!("Could not get remote filename: {}", remote_path.display()))?;
        let mut local_path_buf = env::current_dir()?;
        if let Some(dest_str) = local_dest_str {
            let p = PathBuf::from(dest_str);
            if p.is_dir() || dest_str.ends_with('/') || dest_str.ends_with(std::path::MAIN_SEPARATOR) { local_path_buf = p; local_path_buf.push(remote_filename); } else { local_path_buf = p; }
        } else { local_path_buf.push(remote_filename); }
        if let Some(parent_dir) = local_path_buf.parent() { if !parent_dir.exists() { std::fs::create_dir_all(parent_dir)?; } }

        println!("Downloading '{}' to '{}'", remote_path.display(), local_path_buf.display());
        let sftp_ops = self.sftp.as_ref().ok_or_else(|| SshError::new(ssh2::ErrorCode::Session(-1), "SFTP not initialized"))?;
        let stat_val = sftp_ops.stat(&remote_path).map_err(|e| format!("Remote file '{}' not found: {}", remote_path.display(), e))?;
        if !stat_val.is_file() { return Err(format!("Remote path '{}' is not a file.", remote_path.display()).into()); }
        let mut remote_file = sftp_ops.open(&remote_path)?; // sftp_ops.open returns ssh2::File
        let mut local_file = File::create(&local_path_buf)?;
        let bytes_copied_val = std::io::copy(&mut remote_file, &mut local_file)?;
        println!("Downloaded {} bytes to '{}'.", bytes_copied_val, local_path_buf.display());
        Ok(())
    }

    pub fn cd_remote(&mut self, remote_path_str: &str) -> Result<(), Box<dyn std::error::Error>> {
        let new_path_candidate = self.resolve_remote_path(remote_path_str);
        let sftp_ops = self.sftp.as_ref().ok_or_else(|| SshError::new(ssh2::ErrorCode::Session(-1), "SFTP not initialized"))?;
        match sftp_ops.realpath(&new_path_candidate) {
            Ok(canonical_path) => match sftp_ops.stat(&canonical_path) {
                Ok(stat_val) if stat_val.is_dir() => { self.current_remote_path = canonical_path; Ok(()) }
                Ok(_) => Err(format!("Not a directory: {}", new_path_candidate.display()).into()),
                Err(e) => Err(format!("Cannot stat remote path {}: {}", new_path_candidate.display(), e).into()),
            },
            Err(e) => Err(format!("Invalid remote path {}: {}", new_path_candidate.display(), e).into()),
        }
    }

    pub fn pwd_remote(&self) { println!("Remote directory: {}", self.current_remote_path.display()); }

    pub fn rm_file(&self, remote_file_str: &str) -> Result<(), Box<dyn std::error::Error>> {
        let remote_path = self.resolve_remote_path(remote_file_str);
        let sftp_ops = self.sftp.as_ref().ok_or_else(|| SshError::new(ssh2::ErrorCode::Session(-1), "SFTP not initialized"))?;
        sftp_ops.unlink(&remote_path)?; println!("Removed remote file: {}", remote_path.display()); Ok(())
    }

    pub fn mkdir_remote(&self, remote_dir_str: &str) -> Result<(), Box<dyn std::error::Error>> {
        let remote_path = self.resolve_remote_path(remote_dir_str);
        let sftp_ops = self.sftp.as_ref().ok_or_else(|| SshError::new(ssh2::ErrorCode::Session(-1), "SFTP not initialized"))?;
        sftp_ops.mkdir(&remote_path, 0o755)?; println!("Created remote directory: {}", remote_path.display()); Ok(())
    }

    pub fn rmdir_remote(&self, remote_dir_str: &str) -> Result<(), Box<dyn std::error::Error>> {
        let remote_path = self.resolve_remote_path(remote_dir_str);
        let sftp_ops = self.sftp.as_ref().ok_or_else(|| SshError::new(ssh2::ErrorCode::Session(-1), "SFTP not initialized"))?;
        sftp_ops.rmdir(&remote_path)?; println!("Removed remote directory: {}", remote_path.display()); Ok(())
    }
}

// --- SftpCompleter and related impls ---
pub struct SftpCompleter {
    client: Rc<RefCell<SftpClient>>,
    commands: Vec<String>,
}

impl SftpCompleter {
    fn new(client: Rc<RefCell<SftpClient>>) -> Self {
        SftpCompleter {
            client,
            commands: vec![
                "ls", "dir", "get", "put", "cd", "pwd", "rm", "mkdir", "rmdir", "help", "?", "exit", "quit", "bye",
            ].into_iter().map(String::from).collect(),
        }
    }
}

impl Completer for SftpCompleter {
    type Candidate = String;

    fn complete(&self, line: &str, pos: usize, _ctx: &Context<'_>) -> RustylineResult<(usize, Vec<Self::Candidate>)> {
        let client = self.client.borrow();

        let words: Vec<&str> = line[..pos].split_whitespace().collect();
        let mut current_word_start = 0;
        if let Some(last_space) = line[..pos].rfind(char::is_whitespace) {
            current_word_start = last_space + 1;
        } else if !line.is_empty() && pos > 0 && !line.starts_with(char::is_whitespace) {
            current_word_start = 0;
        } else if pos > 0 {
            current_word_start = pos;
        }

        if words.is_empty() || (words.len() == 1 && pos >= current_word_start && !line[current_word_start..pos].is_empty()) || (words.len() == 1 && line.chars().last().map_or(false, |c| !c.is_whitespace() && pos > current_word_start )) {
            let current_typing = &line[current_word_start..pos];
            let mut candidates: Vec<String> = self.commands.iter()
                .filter(|cmd| cmd.starts_with(current_typing))
                .cloned()
                .collect();

            if candidates.len() == 1 && candidates[0] == current_typing && !current_typing.is_empty() {
                candidates[0].push(' ');
            }
            return Ok((current_word_start, candidates));
        }

        if let Some(command_str) = words.get(0) {
            let remote_path_commands = ["ls", "dir", "cd", "get", "rm", "mkdir", "rmdir"];
            let put_command_str = "put";

            let needs_remote_completion = remote_path_commands.contains(command_str) ||
                                          (command_str == &put_command_str && words.len() > 1 && pos > words[0].len());

            if needs_remote_completion {
                let path_arg_index = if command_str == &put_command_str { 2 } else { 1 };

                if words.len() >= path_arg_index {
                    let mut arg_word_start = 0;
                    let mut current_arg_text = ""; // This was unused in main.rs, still here.

                    let mut char_idx_count = 0;
                    let mut word_idx_count = 0;
                    for word in line.split_whitespace() {
                        word_idx_count += 1;
                        if word_idx_count == path_arg_index {
                            arg_word_start = char_idx_count;
                            if pos >= arg_word_start {
                                // current_arg_text = &line[arg_word_start .. pos.min(arg_word_start + word.len())]; // Original
                                if pos > arg_word_start + word.len() && line.chars().nth(arg_word_start + word.len()) == Some(' ') {
                                    current_arg_text = "";
                                    arg_word_start = pos;
                                } else if pos > arg_word_start + word.len() {
                                     current_arg_text = "";
                                     arg_word_start = pos;
                                } else {
                                     current_arg_text = &line[arg_word_start..pos];
                                }
                            } else {
                                current_arg_text = "";
                                arg_word_start = pos;
                            }
                            break;
                        }
                        char_idx_count += word.len() + 1;
                    }
                    if word_idx_count < path_arg_index && pos > 0 && line.chars().nth(pos-1).map_or(false, |c| c.is_whitespace()) {
                        arg_word_start = pos;
                        current_arg_text = "";
                    }

                    let partial_path = current_arg_text; // Renamed for clarity from original current_arg_text

                    let (base_dir_to_list, prefix_to_match) = if partial_path.contains('/') {
                        let mut components = PathBuf::from(partial_path);
                        let prefix = components.file_name().unwrap_or_default().to_string_lossy().to_string();
                        components.pop();
                        (client.resolve_remote_path(components.to_str().unwrap_or(".")), prefix)
                    } else {
                        (client.current_remote_path.clone(), partial_path.to_string())
                    };

                    let mut candidates = Vec::new();
                    if let Some(sftp_ops) = client.sftp.as_ref() {
                        if let Ok(entries) = sftp_ops.readdir(&base_dir_to_list) {
                            for (path_buf, stat) in entries {
                                if let Some(name_osstr) = path_buf.file_name() {
                                    let name = name_osstr.to_string_lossy();
                                    if name.starts_with(&prefix_to_match) {
                                        let mut suggestion = name.into_owned();
                                        if stat.is_dir() {
                                            suggestion.push('/');
                                        }
                                        candidates.push(suggestion);
                                    }
                                }
                            }
                        }
                        // If readdir fails or sftp_ops is None, candidates remains empty.
                    }
                    return Ok((arg_word_start, candidates));
                }
            }
        }
        Ok((pos, Vec::new()))
    }
}

impl Hinter for SftpCompleter { type Hint = String; }
impl Highlighter for SftpCompleter {}
impl Validator for SftpCompleter {}
impl Helper for SftpCompleter {}

// --- Helper Functions ---
pub fn print_help() {
    println!("Available commands:");
    println!("  ls [path]            List remote directory contents");
    println!("  cd <path>            Change remote working directory");
    println!("  pwd                  Print remote working directory");
    println!("  get <remote> [local] Download file from remote to local");
    println!("  put <local> [remote] Upload file from local to remote");
    println!("  rm <remote_file>     Remove remote file");
    println!("  mkdir <remote_dir>   Create remote directory");
    println!("  rmdir <remote_dir>   Remove remote directory (must be empty)");
    println!("  help                 Show this help message");
    println!("  exit, quit, bye      Disconnect and exit");
}

pub fn process_command(client_rc: &Rc<RefCell<SftpClient>>, command_parts: &[String]) -> Result<(), Box<dyn std::error::Error>> {
    if command_parts.is_empty() { return Ok(()); }
    let command = command_parts[0].to_lowercase();
    let args = &command_parts[1..];

    match command.as_str() {
        "ls" | "dir" => client_rc.borrow().list_dir(args.get(0).map(String::as_str))?,
        "get" => {
            if args.is_empty() { return Err("get: missing <remote_file>".into()); }
            client_rc.borrow().download_file(&args[0], args.get(1).map(String::as_str))?;
        }
        "put" => {
            if args.is_empty() { return Err("put: missing <local_file>".into()); }
            client_rc.borrow().upload_file(&args[0], args.get(1).map(String::as_str))?;
        }
        "cd" => {
            if args.is_empty() { return Err("cd: missing <remote_path>".into()); }
            client_rc.borrow_mut().cd_remote(&args[0])?;
        }
        "pwd" => client_rc.borrow().pwd_remote(),
        "rm" => {
            if args.is_empty() { return Err("rm: missing <remote_file>".into()); }
            client_rc.borrow().rm_file(&args[0])?;
        }
        "mkdir" => {
            if args.is_empty() { return Err("mkdir: missing <remote_dir>".into()); }
            client_rc.borrow().mkdir_remote(&args[0])?;
        }
        "rmdir" => {
            if args.is_empty() { return Err("rmdir: missing <remote_dir>".into()); }
            client_rc.borrow().rmdir_remote(&args[0])?;
        }
        "help" | "?" => print_help(),
        "exit" | "quit" | "bye" => return Err("exit_command".into()), // Special error to signal exit
        _ => eprintln!("Unknown command: '{}'. Type 'help'.", command),
    }
    Ok(())
}

pub fn interactive_shell(client_rc: Rc<RefCell<SftpClient>>) -> Result<(), Box<dyn std::error::Error>> {
    println!("Connected to {}. Type 'help' for commands.", client_rc.borrow().connected_host_string);
    client_rc.borrow().pwd_remote();

    let completer = SftpCompleter::new(client_rc.clone());
    let mut rl = Editor::new()?;
    rl.set_helper(Some(completer));

    loop {
        let prompt = {
            let client_borrow = client_rc.borrow();
            let current_dir_name = client_borrow.current_remote_path.file_name().unwrap_or_default().to_string_lossy();
            format!("sftp:{}> ", if current_dir_name.is_empty() { "/" } else { &current_dir_name } )
        };

        match rl.readline(&prompt) {
            Ok(line) => {
                if !line.trim().is_empty() {
                    let _ = rl.add_history_entry(line.as_str());
                }
                let trimmed_line = line.trim();
                if trimmed_line.is_empty() { continue; }
                let command_parts: Vec<String> = trimmed_line.split_whitespace().map(String::from).collect();

                match process_command(&client_rc, &command_parts) {
                    Ok(_) => {}
                    Err(e) if e.to_string() == "exit_command" => { println!("Exiting."); break; }
                    Err(e) => eprintln!("Error: {}", e),
                }
            }
            Err(ReadlineError::Interrupted) => { println!("^C"); } // Or break, or handle as command
            Err(ReadlineError::Eof) => { println!("exit"); break; }
            Err(err) => { eprintln!("Readline error: {:?}", err); break; }
        }
    }
    Ok(())
}
